import { injectable, decorate, multiInject, optional, inject } from 'inversify';
import { parse, format } from 'auth-header';
import { tryParseBoolean, jsonProperty, arrayOf, keyValueOf, any, jsonObject, JsonConverter, JsonConverterError, normalizeConverterAndArgs, stringConverter, numberConverter, booleanConverter, arrayConverter, objectConverter, JsonConverterMapper } from 'tipify';
import { verify } from 'jsonwebtoken';
import * as _request from 'request';
import { getNamespace, createNamespace } from 'cls-hooked';
import * as _pino from 'pino';
import { Logger as Logger$1 } from 'pino';
import { inspect } from 'util';
import * as _fastify from 'fastify';
import * as fastifyCompress from 'fastify-compress';
import * as helmet from 'fastify-helmet';
import * as fastifyMetrics from 'fastify-metrics';
import { generate } from 'shortid';
import { open, url, close } from 'inspector';
import 'reflect-metadata';
import * as _urlJoin from 'url-join';
import { Logger, MongoClient, MongoError } from 'mongodb';
import { ObjectId } from 'bson';
import * as _merge from 'deepmerge';
import * as fastifyStatic from 'fastify-static';
import { join } from 'path';
import swaggerUiDist from 'swagger-ui-dist';
import { QuerySearch } from '@henry781/querysearch';
import * as _accepts from 'accepts';
import * as _flatstr from 'flatstr';
import * as _yaml from 'js-yaml';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

let AuthProvider = class AuthProvider {
};
AuthProvider = __decorate([
    injectable()
], AuthProvider);

const types = {
    AuthProvider: 'AuthProvider',
    Controller: 'Controller',
    Healthcheck: 'Healthcheck',
    Logger: 'Logger',
    MongoService: 'MongoService',
};

class AuthUtil {
    static parseAuthorizationHeader(request) {
        if (!request.headers.authorization) {
            return undefined;
        }
        return parse(request.headers.authorization);
    }
    static normalizeAuthOptions(authOptions) {
        if (typeof (authOptions) === 'string') {
            return [{ providerName: authOptions }];
        }
        else if (Array.isArray(authOptions)) {
            return authOptions.map((a) => {
                return { providerName: a };
            });
        }
        else {
            return Object.keys(authOptions)
                .map((providerName) => {
                return Object.assign(Object.assign({}, authOptions[providerName]), { providerName });
            });
        }
    }
    static getAuthProviders(container, authOptions) {
        return authOptions.map((options) => {
            return {
                options,
                provider: container.getNamed(types.AuthProvider, options.providerName),
            };
        });
    }
}

const environment = {
    AUTH_BASIC_LOGIN: process.env.AUTH_BASIC_LOGIN || 'login',
    AUTH_BASIC_PASSWORD: process.env.AUTH_BASIC_PASSWORD || 'password',
    AUTH_JWT_APPLICATION: process.env.AUTH_JWT_APPLICATION || '',
    AUTH_JWT_AUTHORIZATION_URL: process.env.AUTH_JWT_AUTHORIZATION_URL || '',
    AUTH_JWT_CERTIFICATE: process.env.AUTH_JWT_CERTIFICATE || '',
    LOG_LEVEL: process.env.LOG_LEVEL || 'trace',
    LOG_PRETTY: process.env.LOG_PRETTY ? tryParseBoolean(process.env.LOG_PRETTY) : false,
    MONGO_DB: process.env.MONGO_DB || 'main',
    MONGO_URL: process.env.MONGO_URL || 'mongodb://localhost:27017',
    PORT: parseInt(process.env.PORT, 10) || 2000,
    SWAGGER_PATH: process.env.SWAGGER_PATH,
};

let Principal = class Principal {
    constructor(options) {
        if (options) {
            this._login = options.login;
            this._email = options.email;
            this._token = options.token;
            this._firstname = options.firstname;
            this._lastname = options.lastname;
            this._roles = options.roles;
            this._params = options.params;
            if (options.password !== undefined) {
                const base64Token = Buffer.from(`${this._login}:${options.password}`).toString('base64');
                this._token = { scheme: 'Basic', token: base64Token, params: {} };
            }
        }
    }
    get login() {
        return this._login;
    }
    get email() {
        return this._email;
    }
    get token() {
        return this._token;
    }
    get firstname() {
        return this._firstname;
    }
    get lastname() {
        return this._lastname;
    }
    get roles() {
        return this._roles;
    }
    get params() {
        return this._params;
    }
    hasRole(role) {
        if (!this._roles) {
            return false;
        }
        if (Array.isArray(role)) {
            return this._roles.some((r) => role.indexOf(r) !== -1);
        }
        else {
            return this._roles.indexOf(role) !== -1;
        }
    }
};
__decorate([
    jsonProperty('login'),
    __metadata("design:type", String)
], Principal.prototype, "_login", void 0);
__decorate([
    jsonProperty('email'),
    __metadata("design:type", String)
], Principal.prototype, "_email", void 0);
__decorate([
    jsonProperty('firstname'),
    __metadata("design:type", String)
], Principal.prototype, "_firstname", void 0);
__decorate([
    jsonProperty('lastname'),
    __metadata("design:type", String)
], Principal.prototype, "_lastname", void 0);
__decorate([
    jsonProperty('roles', arrayOf(String)),
    __metadata("design:type", Array)
], Principal.prototype, "_roles", void 0);
__decorate([
    jsonProperty('params', keyValueOf(String, any())),
    __metadata("design:type", Object)
], Principal.prototype, "_params", void 0);
Principal = __decorate([
    jsonObject(),
    __metadata("design:paramtypes", [Object])
], Principal);

class BasicAuthProvider extends AuthProvider {
    constructor(options = DEFAULT_BASIC_AUTH_PROVIDER_OPTIONS) {
        super();
        this._options = options;
    }
    get options() {
        return this._options;
    }
    authenticate(request, token, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!token) {
                throw new Error('Authorization header is missing');
            }
            if (!token.scheme || token.scheme.toLowerCase() !== 'basic') {
                throw new Error('Authorization scheme should be \'basic\'');
            }
            const decoded = Buffer.from(token.token.toString(), 'base64')
                .toString('ascii');
            const separatorPosition = decoded.indexOf(':');
            const login = decoded.substring(0, separatorPosition);
            const password = decoded.substring(separatorPosition + 1);
            const userOptions = this.options[login];
            if (!userOptions || userOptions.password !== password) {
                throw new Error('Bad credentials');
            }
            return this.provideUser(login, userOptions, token);
        });
    }
    provideUser(login, userOptions, token) {
        return new Principal({
            email: userOptions.email,
            firstname: userOptions.firstname,
            lastname: userOptions.lastname,
            login,
            roles: userOptions.roles,
            token,
        });
    }
}
const DEFAULT_BASIC_AUTH_PROVIDER_OPTIONS = {
    [environment.AUTH_BASIC_LOGIN]: {
        password: environment.AUTH_BASIC_PASSWORD,
    },
};

class JwtAuthProvider extends AuthProvider {
    constructor(options = DEFAULT_JWT_AUTH_PROVIDER_OPTIONS) {
        super();
        this._options = options;
        this._certificate = '-----BEGIN CERTIFICATE-----\n' + this._options.certificate + '\n-----END CERTIFICATE-----';
    }
    get options() {
        return this._options;
    }
    authenticate(request, token, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!token) {
                throw new Error('Authorization header is missing');
            }
            if (!token.scheme || token.scheme.toLowerCase() !== 'bearer') {
                throw new Error('Authorization scheme should be \'bearer\'');
            }
            const jwtToken = Array.isArray(token.token) ? token.token[0] : token.token;
            const decodedToken = verify(jwtToken, this._certificate);
            return this.provideUser(decodedToken, token);
        });
    }
    provideUser(decodedToken, token) {
        const resourceAccess = decodedToken['resource_access'];
        const roles = resourceAccess && resourceAccess[this._options.application]
            && resourceAccess[this._options.application].roles
            ? resourceAccess[this._options.application].roles
            : [];
        return new Principal({
            email: decodedToken['email'],
            firstname: decodedToken['given_name'],
            lastname: decodedToken['family_name'],
            login: decodedToken['preferred_username'],
            roles,
            token,
        });
    }
}
const DEFAULT_JWT_AUTH_PROVIDER_OPTIONS = {
    application: environment.AUTH_JWT_APPLICATION,
    authorizationUrl: environment.AUTH_JWT_AUTHORIZATION_URL,
    certificate: environment.AUTH_JWT_CERTIFICATE,
};

const jsonConverter = new JsonConverter({
    deserialize: { tryParse: true, keepObjectFieldValues: false },
    serialize: { unsafe: true },
});

const pino = _pino;
const DEFAULT_LOGGER_OPTIONS = {
    level: environment.LOG_LEVEL,
    prettyPrint: environment.LOG_PRETTY ? { forceColor: true } : undefined,
    timestamp: () => `,"time":"${new Date().toISOString()}"`,
    useLevelLabels: true,
};
const loggerService = pino(DEFAULT_LOGGER_OPTIONS);
function getLogger(method, module) {
    const session = getNamespace('app');
    const logger = (session && session.get('log')) ? session.get('log') : loggerService;
    if (!method && !module) {
        return logger;
    }
    else if (typeof method === 'string') {
        if (module && module.constructor) {
            return logger.child({
                method,
                module: module.constructor.name,
            });
        }
        else {
            return logger.child({
                method,
            });
        }
    }
    else {
        return logger.child({ method: method.join('.') });
    }
}
function getReqId() {
    const session = getNamespace('app');
    return session ? session.get('reqId') : undefined;
}

class WebServiceError extends Error {
    constructor(message, status = 500, cause) {
        super(message);
        this._status = status;
        this._cause = cause;
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
    get status() {
        return this._status;
    }
    get cause() {
        return this._cause;
    }
    [inspect.custom || 'inspect']() {
        let err = this.cause;
        let fullStack = this.stack;
        while (err) {
            fullStack += '\n\ncaused by:\n\n';
            fullStack += err.stack || err.message;
            err = err.cause;
        }
    }
}

class GenericClientError extends WebServiceError {
    constructor(message, status = 500, cause, response, body) {
        super(message, status, cause);
        this._response = response;
        this._body = body;
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
    get response() {
        return this._response;
    }
    get body() {
        return this._body;
    }
}

let GenericClient = class GenericClient {
    constructor() {
        this.request = _request;
    }
    get(uri, options) {
        return this.http(uri, options, 'get');
    }
    post(uri, options) {
        return this.http(uri, options, 'post');
    }
    delete(uri, options) {
        return this.http(uri, options, 'delete');
    }
    put(uri, options) {
        return this.http(uri, options, 'put');
    }
    patch(uri, options) {
        return this.http(uri, options, 'patch');
    }
    http(uri, options, method) {
        const logger = getLogger('http', this);
        logger.debug(`requesting <${uri}>`);
        const httpOptions = this.buildHttpOptions(options, method);
        return new Promise((resolve, reject) => {
            this.request(uri, httpOptions, (err, response, body) => {
                if (err) {
                    logger.error(`error calling <${uri}> :`, err);
                    const error = new GenericClientError(`error calling <${uri}>`, 500, err, response, body);
                    reject(error);
                }
                else {
                    logger.debug(`request on <${uri}> complete`);
                    if (response.statusCode !== options.expectedStatus) {
                        const msg = `expecting status <${options.expectedStatus}> calling <${uri}>, got <${response.statusCode}>`;
                        logger.error(msg);
                        logger.debug('got body', body);
                        const error = new GenericClientError(msg, 500, undefined, response, body);
                        reject(error);
                    }
                    else {
                        if (options.deserializer === false) {
                            resolve(body);
                        }
                        else if (typeof (options.deserializer) === 'function') {
                            resolve(options.deserializer(body));
                        }
                        else if (options.deserializeType) {
                            resolve(jsonConverter.deserialize(body, options.deserializeType));
                        }
                        else {
                            resolve();
                        }
                    }
                }
            });
        });
    }
    buildHttpOptions(options, method) {
        const logger = getLogger('buildHttpOptions', this);
        const httpOptions = {
            headers: {},
            json: true,
            method,
        };
        const reqId = getReqId();
        if (reqId) {
            httpOptions.headers['request-id'] = reqId;
        }
        if (options.httpOptions) {
            logger.debug('override httpOptions');
            Object.assign(httpOptions, options.httpOptions);
            logger.debug('got httpOptions', httpOptions);
        }
        if (options.token) {
            logger.debug('setting authorization header from given token');
            httpOptions.headers.Authorization = options.token;
        }
        else if (options.principal && options.principal.token) {
            logger.debug('setting authorization header from give principal');
            httpOptions.headers.Authorization = format(options.principal.token);
        }
        if (options.body) {
            logger.debug('setting body');
            if (options.serializer === false) {
                httpOptions.body = options.body;
            }
            else if (typeof (options.serializer) === 'function') {
                logger.debug('serializing body');
                httpOptions.body = options.serializer(options.body);
            }
            else {
                httpOptions.body = jsonConverter.serialize(options.body, undefined, { unsafe: true });
            }
        }
        return httpOptions;
    }
};
GenericClient = __decorate([
    injectable(),
    __metadata("design:paramtypes", [])
], GenericClient);
const genericClient = new GenericClient();

const ROUTE_CONTROLLER = Symbol('route:controller');
function controller(options) {
    return (target) => {
        decorate(injectable(), target);
        if (!options) {
            options = {};
        }
        else if (typeof (options) === 'string') {
            options = {
                url: options,
            };
        }
        Reflect.defineMetadata(ROUTE_CONTROLLER, options, target.prototype);
    };
}

const ROUTE_METHOD = Symbol('route:method');
function http(options) {
    return (target, propertyKey) => {
        Reflect.defineMetadata(ROUTE_METHOD, options, target, propertyKey);
    };
}
function httpGet(options) {
    if (!options) {
        options = {};
    }
    else if (typeof (options) === 'string') {
        options = {
            url: options,
        };
    }
    return http(Object.assign(options, { method: 'GET' }));
}
function httpPost(options) {
    if (!options) {
        options = {};
    }
    else if (typeof (options) === 'string') {
        options = {
            url: options,
        };
    }
    return http(Object.assign(options ? options : {}, { method: 'POST' }));
}
function httpPut(options) {
    if (!options) {
        options = {};
    }
    else if (typeof (options) === 'string') {
        options = {
            url: options,
        };
    }
    return http(Object.assign(options, { method: 'PUT' }));
}
function httpPatch(options) {
    if (!options) {
        options = {};
    }
    else if (typeof (options) === 'string') {
        options = {
            url: options,
        };
    }
    return http(Object.assign(options, { method: 'PATCH' }));
}
function httpDelete(options) {
    if (!options) {
        options = {};
    }
    else if (typeof (options) === 'string') {
        options = {
            url: options,
        };
    }
    return http(Object.assign(options, { method: 'DELETE' }));
}

const ROUTE_PARAMS = Symbol('route:params');
function param(options) {
    return (target, propertyKey, parameterIndex) => {
        if (!options.paramType) {
            const paramTypes = Reflect.getMetadata('design:paramtypes', target, propertyKey);
            options.paramType = paramTypes[parameterIndex];
        }
        const params = Reflect.getOwnMetadata(ROUTE_PARAMS, target, propertyKey) || [];
        params[parameterIndex] = options;
        Reflect.defineMetadata(ROUTE_PARAMS, params, target, propertyKey);
    };
}
function pathParam(name, description) {
    return param({
        description,
        name,
        type: 'path',
    });
}
function queryParam(name, description) {
    return param({
        description,
        name,
        type: 'query',
    });
}
function querySearch() {
    return param({
        type: 'search',
    });
}
function auth() {
    return param({
        type: 'auth',
    });
}
function httpRequest() {
    return param({
        type: 'httpRequest',
    });
}
function httpReply() {
    return param({
        type: 'httpReply',
    });
}
function body(paramType) {
    return param({
        paramType,
        type: 'body',
    });
}

const urlJoin = _urlJoin;
class CommonUtil {
    static buildUrl(controllerOptions, methodOptions) {
        if (controllerOptions.url && methodOptions.url) {
            return urlJoin(controllerOptions.url, methodOptions.url);
        }
        else if (methodOptions.url) {
            return methodOptions.url;
        }
        else if (controllerOptions.url) {
            return controllerOptions.url;
        }
        else {
            return '';
        }
    }
    static getAllEndpoints(container) {
        const endpoints = [];
        const controllers = container.isBound(types.Controller)
            ? container.getAll(types.Controller) : [];
        controllers.forEach((controller) => {
            const methods = Object.getOwnPropertyNames(controller.constructor.prototype);
            methods.forEach((method) => {
                const controllerOptions = Reflect.getMetadata(ROUTE_CONTROLLER, controller);
                const methodOptions = Reflect.getMetadata(ROUTE_METHOD, controller, method);
                if (!methodOptions) {
                    return;
                }
                const paramsOptions = Reflect.getMetadata(ROUTE_PARAMS, controller, method) || [];
                const url = CommonUtil.buildUrl(controllerOptions, methodOptions);
                endpoints.push({
                    controller,
                    controllerOptions,
                    method,
                    methodOptions,
                    paramsOptions,
                    url,
                });
            });
        });
        return endpoints;
    }
}

var AdminController_1;
let AdminController = AdminController_1 = class AdminController {
    constructor(options) {
        this.options = options;
        this.logger = loggerService.child({ module: 'AdminController' });
        AdminController_1.decorateMethods(options);
    }
    static decorateMethods(options) {
        const auth = options ? options.auth : undefined;
        decorate(httpPut({ url: 'logging/level/:level', auth }), AdminController_1.prototype, 'setLoggingLevel');
        decorate(httpPut({ url: 'inspector/enabled', auth }), AdminController_1.prototype, 'enableInspector');
        decorate(httpPut({ url: 'inspector/disabled', auth }), AdminController_1.prototype, 'disableInspector');
    }
    setLoggingLevel(level) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = this.logger.child({ method: 'setLoggingLevel' });
            const value = loggerService.levels.labels[loggerService.levels.values[level]];
            if (value === undefined) {
                throw new WebServiceError(`level <${level}> is unknown`, 400);
            }
            logger.info(`logging level changed to <${value}>`);
            loggerService.level = value;
        });
    }
    enableInspector(port) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = this.logger.child({ method: 'enableInspector' });
            const inspectorPort = port ? port :
                this.options.inspectorPort ? this.options.inspectorPort : undefined;
            open(inspectorPort, this.options.inspectorHost);
            logger.info('inspector enabled');
            return {
                url: url(),
            };
        });
    }
    disableInspector() {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = this.logger.child({ method: 'disableInspector' });
            close();
            logger.info('inspector disabled');
        });
    }
};
__decorate([
    __param(0, pathParam('level')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], AdminController.prototype, "setLoggingLevel", null);
__decorate([
    __param(0, queryParam('port')),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Number]),
    __metadata("design:returntype", Promise)
], AdminController.prototype, "enableInspector", null);
AdminController = AdminController_1 = __decorate([
    controller('/admin'),
    __metadata("design:paramtypes", [Object])
], AdminController);

let HealthcheckController = class HealthcheckController {
    constructor(healthchecks = []) {
        this.healthchecks = healthchecks;
    }
    check(reply) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = {
                checks: {},
                healthy: true,
            };
            const checks = Promise.all(this.healthchecks.map((check) => check.check()
                .then((checkResult) => {
                result.checks[check.getName()] = {
                    healthy: true,
                    result: checkResult,
                };
            })
                .catch((err) => {
                result.healthy = false;
                result.checks[check.getName()] = {
                    error: err.message,
                    healthy: false,
                };
            })));
            yield checks;
            const status = result.healthy ? 200 : 500;
            return reply.status(status).send(result);
        });
    }
};
__decorate([
    httpGet(),
    __param(0, httpReply()),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], HealthcheckController.prototype, "check", null);
HealthcheckController = __decorate([
    controller('/healthcheck'),
    __param(0, multiInject(types.Healthcheck)), __param(0, optional()),
    __metadata("design:paramtypes", [Array])
], HealthcheckController);

const clsNamespace = createNamespace('app');
function loggerContextMiddleware(request, reply, next) {
    clsNamespace.bind(request);
    clsNamespace.bind(reply);
    clsNamespace.run(() => {
        clsNamespace.set('log', request.log);
        clsNamespace.set('reqId', request.id);
        next();
    });
}

const MONGO_COLLECTION = 'mongo:collection';
function collection(name) {
    return (target) => {
        Reflect.defineMetadata(MONGO_COLLECTION, name, target.prototype);
    };
}

var MongoService_1, _a;
let MongoService = MongoService_1 = class MongoService {
    constructor(logger) {
        this.logger = logger.child({ module: 'MongoService' });
    }
    static getCollectionForType(type) {
        return Reflect.getMetadata(MONGO_COLLECTION, type.prototype);
    }
    static getCollection(obj) {
        return MongoService_1.getCollectionForType(obj.constructor);
    }
    get db() {
        return this._db;
    }
    connect(options = DEFAULT_MONGO_OPTIONS) {
        return __awaiter(this, void 0, void 0, function* () {
            const logger = this.logger.child({ method: 'connect' });
            Logger.setCurrentLogger((msg, state) => {
                this.logger.debug(msg, state);
            });
            try {
                this.client = yield MongoClient.connect(options.uri, options.client);
                this._db = this.client.db(options.dbName);
                logger.info('connected to mongodb successfully');
            }
            catch (err) {
                logger.error('failed to connect to mongodb', err);
                this.error = err;
            }
        });
    }
    doAction(action) {
        if (this.error) {
            throw this.error;
        }
        else if (!this.client || !this._db) {
            throw new MongoError('database is not ready');
        }
        else {
            return action();
        }
    }
    isMaster() {
        return this.doAction(() => this._db.command({ isMaster: 1 }));
    }
    findOne(type, query, options) {
        const collection = MongoService_1.getCollectionForType(type);
        return this.doAction(() => this._db.collection(collection).findOne(query, options))
            .then((json) => jsonConverter.deserialize(json, type));
    }
    insertOne(obj, options) {
        const json = jsonConverter.serialize(obj);
        const collection = MongoService_1.getCollection(obj);
        return this.doAction(() => this._db.collection(collection).insertOne(json, options));
    }
    insertMany(type, obj, options) {
        const json = jsonConverter.serialize(obj);
        const collection = MongoService_1.getCollectionForType(type);
        return this.doAction(() => this._db.collection(collection).insertMany(json, options));
    }
    find(type, query = {}, sort = {}, limit, offset) {
        const collection = MongoService_1.getCollectionForType(type);
        return this.doAction(() => {
            const cursor = this._db.collection(collection)
                .find(query)
                .sort(sort);
            if (limit !== undefined) {
                cursor.limit(limit);
            }
            if (offset !== undefined) {
                cursor.skip(offset);
            }
            return cursor.toArray();
        })
            .then((json) => jsonConverter.deserialize(json, arrayOf(type)));
    }
    aggregate(type, pipeline, options, outputType = type) {
        const collection = MongoService_1.getCollectionForType(type);
        return this.doAction(() => {
            const cursor = this._db.collection(collection)
                .aggregate(pipeline, options);
            return cursor.toArray();
        })
            .then((json) => outputType ? jsonConverter.deserialize(json, arrayOf(outputType)) : json);
    }
    search(type, search) {
        return this.find(type, search.filter, search.sort, search.limit, search.offset);
    }
    deleteOne(type, query = {}) {
        const collection = MongoService_1.getCollectionForType(type);
        return this.doAction(() => this._db.collection(collection).deleteOne(query));
    }
    deleteMany(type, query = {}) {
        const collection = MongoService_1.getCollectionForType(type);
        return this.doAction(() => this._db.collection(collection).deleteMany(query));
    }
    replaceOne(type, query = {}, obj = {}, options) {
        const collection = MongoService_1.getCollectionForType(type);
        const document = jsonConverter.serialize(obj);
        return this.doAction(() => this._db.collection(collection).replaceOne(query, document, options));
    }
    updateOne(type, query = {}, update = {}, options) {
        const collection = MongoService_1.getCollectionForType(type);
        return this.doAction(() => this._db.collection(collection).updateOne(query, update, options));
    }
    updateMany(type, query = {}, update = {}, options) {
        const collection = MongoService_1.getCollectionForType(type);
        return this.doAction(() => this._db.collection(collection).updateMany(query, update, options));
    }
    count(type, query = {}, options) {
        const collection = MongoService_1.getCollectionForType(type);
        return this.doAction(() => this._db.collection(collection).countDocuments(query, options));
    }
    close() {
        return this.client.close();
    }
};
MongoService = MongoService_1 = __decorate([
    injectable(),
    __param(0, inject(types.Logger)),
    __metadata("design:paramtypes", [typeof (_a = typeof Logger$1 !== "undefined" && Logger$1) === "function" ? _a : Object])
], MongoService);
const DEFAULT_MONGO_OPTIONS = {
    client: {
        reconnectInterval: 1000,
        reconnectTries: 60,
        useNewUrlParser: true,
    },
    dbName: environment.MONGO_DB,
    uri: environment.MONGO_URL,
};

let MongoHealthcheck = class MongoHealthcheck {
    constructor(mongoService) {
        this.mongoService = mongoService;
    }
    getName() {
        return 'mongodb';
    }
    check() {
        try {
            return this.mongoService.isMaster()
                .then((result) => {
                if (!result.ismaster) {
                    throw new Error('db is not master');
                }
                if (result.readOnly) {
                    throw new Error('db is readonly');
                }
                return result;
            });
        }
        catch (err) {
            return Promise.reject(err);
        }
    }
};
MongoHealthcheck = __decorate([
    injectable(),
    __param(0, inject(types.MongoService)),
    __metadata("design:paramtypes", [MongoService])
], MongoHealthcheck);

const objectIdCustomConverter = {
    deserialize(obj) {
        if (!obj || obj instanceof ObjectId) {
            return obj;
        }
        else if (typeof (obj) === 'string') {
            return new ObjectId(obj);
        }
        else {
            throw new JsonConverterError('cannot deserialize to object id');
        }
    },
    serialize(obj) {
        if (!obj) {
            return obj;
        }
        else if (typeof (obj) === 'string') {
            return obj;
        }
        else {
            return obj.toHexString();
        }
    },
};

const OPENAPI_DEFAULT_CONFIGURATION = {
    openapi: '3.0.0',
};

class SwaggerTipifyUtil {
    static buildOpenApiSchema(type, schemas) {
        const c = normalizeConverterAndArgs(type);
        if (c.converter === stringConverter) {
            return { type: 'string' };
        }
        else if (c.converter === numberConverter) {
            return { type: 'number' };
        }
        else if (c.converter === booleanConverter) {
            return { type: 'boolean' };
        }
        else if (c.converter === arrayConverter) {
            if (!c.args) {
                return { type: 'array' };
            }
            const itemConverterDefinition = normalizeConverterAndArgs(c.args.itemConverter);
            return {
                items: SwaggerTipifyUtil.buildOpenApiSchema(itemConverterDefinition, schemas),
                type: 'array',
            };
        }
        else if (c.converter === objectConverter) {
            if (!c.args) {
                return { type: 'object' };
            }
            const objectType = c.args.type;
            const mapping = JsonConverterMapper.getMappingForType(objectType);
            if (!mapping) {
                return { type: 'object' };
            }
            if (!schemas[mapping.type.name]) {
                const schema = {
                    properties: {},
                    type: 'object',
                };
                if (!mapping.parent) {
                    schemas[mapping.type.name] = schema;
                }
                else {
                    const parent = mapping.parent.type;
                    schemas[mapping.type.name] = {
                        allOf: [
                            {
                                $ref: `#/components/schemas/${parent.name}`,
                            },
                            schema,
                        ],
                    };
                    SwaggerTipifyUtil.buildOpenApiSchema(parent, schemas);
                }
                for (const property of mapping.properties) {
                    schema.properties[property.serializedName] = SwaggerTipifyUtil.buildOpenApiSchema({ converter: property.converter, args: property.args }, schemas);
                }
            }
            return { $ref: `#/components/schemas/${objectType.name}` };
        }
    }
}

const merge = _merge;
class SwaggerGenerator {
    static translateUrl(url) {
        return url ? url.replace(/:(\w+)/g, '{$1}') : '';
    }
    static buildConfiguration(container, userDefinedConfiguration) {
        const logger = SwaggerGenerator.logger.child({ method: 'buildConfiguration' });
        let configuration = OPENAPI_DEFAULT_CONFIGURATION;
        configuration = SwaggerGenerator.buildAuthenticationConfiguration(container, configuration);
        CommonUtil.getAllEndpoints(container).forEach((endpoint) => {
            configuration = merge(configuration, SwaggerGenerator.buildConfigurationForEndpoint(endpoint));
        });
        if (userDefinedConfiguration) {
            configuration = merge(configuration, userDefinedConfiguration);
        }
        logger.debug('open api configuration built');
        return configuration;
    }
    static buildAuthenticationConfiguration(container, configuration) {
        const authenticationProviders = container.isBound(types.AuthProvider)
            ? container.getAll(types.AuthProvider) : [];
        authenticationProviders.forEach((provider) => {
            if (provider instanceof JwtAuthProvider) {
                const authConfiguration = {
                    components: {
                        securitySchemes: {
                            jwt: {
                                flows: {
                                    implicit: {
                                        authorizationUrl: provider.options.authorizationUrl,
                                        scopes: {},
                                    },
                                },
                                type: 'oauth2',
                            },
                        },
                    },
                };
                configuration = merge(configuration, authConfiguration);
            }
            else if (provider instanceof BasicAuthProvider) {
                const authConfiguration = {
                    components: {
                        securitySchemes: {
                            basic: {
                                scheme: 'basic',
                                type: 'http',
                            },
                        },
                    },
                };
                configuration = merge(configuration, authConfiguration);
            }
        });
        return configuration;
    }
    static buildConfigurationForParameter(configuration, methodOptions, paramOptions) {
        switch (paramOptions.type) {
            case 'query':
                methodOptions.parameters.push({
                    in: 'query',
                    name: paramOptions.name,
                    schema: SwaggerTipifyUtil.buildOpenApiSchema(paramOptions.paramType, configuration.components.schemas),
                });
                break;
            case 'search':
                methodOptions.parameters.push({
                    in: 'query',
                    name: 'offset',
                    schema: {
                        type: 'integer',
                    },
                }, {
                    in: 'query',
                    name: 'limit',
                    schema: {
                        type: 'integer',
                    },
                }, {
                    description: 'Filter by entering {field}[eq]={value}',
                    explode: true,
                    in: 'query',
                    name: 'filter',
                    schema: {
                        items: {
                            type: 'string',
                        },
                        type: 'array',
                    },
                }, {
                    description: 'Sort by entering {field}={ASC|DESC}',
                    explode: true,
                    in: 'query',
                    name: 'sort',
                    schema: {
                        items: {
                            type: 'string',
                        },
                        type: 'array',
                    },
                });
                break;
            case 'path':
                methodOptions.parameters.push({
                    in: 'path',
                    name: paramOptions.name,
                    required: true,
                    schema: SwaggerTipifyUtil.buildOpenApiSchema(paramOptions.paramType, configuration.components.schemas),
                });
                break;
            case 'body':
                const paramType = paramOptions.paramType;
                const contentType = 'application/json';
                const requestBody = {
                    content: {
                        [contentType]: {
                            schema: SwaggerTipifyUtil.buildOpenApiSchema(paramType, configuration.components.schemas),
                        },
                    },
                    description: paramOptions.description,
                    required: true,
                };
                methodOptions.requestBody = requestBody;
                break;
        }
        return configuration;
    }
    static buildConfigurationForEndpoint(endpoint) {
        const logger = SwaggerGenerator.logger.child({ method: 'buildConfigurationForEndpoint' });
        const url = SwaggerGenerator.translateUrl(endpoint.url);
        const method = endpoint.methodOptions.method.toLowerCase();
        let endpointConfiguration = {
            parameters: [],
        };
        if (endpoint.controllerOptions.swagger) {
            logger.trace('merging endpoint configuration with user defined configuration (controller)');
            endpointConfiguration = merge(endpointConfiguration, endpoint.controllerOptions.swagger);
        }
        const auth = endpoint.methodOptions.auth;
        if (auth) {
            logger.trace('authentication enabled');
            endpointConfiguration.security = AuthUtil.normalizeAuthOptions(auth)
                .map((a) => {
                logger.trace(`authentication <${a.providerName}> enabled`);
                return { [a.providerName]: [] };
            });
        }
        let configuration = {
            components: {
                schemas: {},
            },
            paths: {
                [url]: {
                    [method]: endpointConfiguration,
                },
            },
        };
        endpoint.paramsOptions.forEach((param) => {
            configuration = SwaggerGenerator.buildConfigurationForParameter(configuration, endpointConfiguration, param);
        });
        if (endpoint.methodOptions.swagger) {
            logger.trace('merging endpoint configuration with user defined configuration');
            configuration.paths[url][method] = merge(configuration.paths[url][method], endpoint.methodOptions.swagger);
        }
        if (!configuration.paths[url][method].responses) {
            logger.trace('adding default responses');
            configuration.paths[url][method].responses = {
                200: {
                    content: {
                        'application/json': {
                            schema: {
                                type: 'object',
                            },
                        },
                        'application/x-yaml': {
                            schema: {
                                type: 'object',
                            },
                        },
                    },
                    description: '',
                },
            };
        }
        return configuration;
    }
    static getPlugin(instance, opts, next) {
        const logger = SwaggerGenerator.logger.child({ method: 'getPlugin' });
        logger.info('initializing swagger...');
        let configuration = SwaggerGenerator.buildConfiguration(opts.container);
        if (opts.configuration) {
            configuration = merge(configuration, opts.configuration);
        }
        const index = SwaggerGenerator.INDEX_HTML_TEMPLATE;
        instance.get('/docs', (request, reply) => {
            reply.type('text/html').send(index);
        });
        instance.get('/docs/swagger.json', (request, reply) => {
            reply.send(configuration);
        });
        instance.register(fastifyStatic, {
            index: [],
            prefix: '/docs',
            root: environment.SWAGGER_PATH
                ? join(__dirname, environment.SWAGGER_PATH)
                : swaggerUiDist.getAbsoluteFSPath(),
        });
        logger.info('swagger initialized');
        next();
    }
}
SwaggerGenerator.INDEX_HTML_TEMPLATE = '<!DOCTYPE html>\n' +
    '<html lang="en">\n' +
    '  <head>\n' +
    '    <meta charset="UTF-8">\n' +
    '    <title>SwaggerPlugin UI</title>\n' +
    '    <link rel="stylesheet" type="text/css" href="./docs/swagger-ui.css" >\n' +
    '    <link rel="icon" type="image/png" href="./docs/favicon-32x32.png" sizes="32x32" />\n' +
    '    <link rel="icon" type="image/png" href="./docs/favicon-16x16.png" sizes="16x16" />\n' +
    '    <style>\n' +
    '      html\n' +
    '      {\n' +
    '        box-sizing: border-box;\n' +
    '        overflow: -moz-scrollbars-vertical;\n' +
    '        overflow-y: scroll;\n' +
    '      }\n' +
    '\n' +
    '      *,\n' +
    '      *:before,\n' +
    '      *:after\n' +
    '      {\n' +
    '        box-sizing: inherit;\n' +
    '      }\n' +
    '\n' +
    '      body\n' +
    '      {\n' +
    '        margin:0;\n' +
    '        background: #fafafa;\n' +
    '      }\n' +
    '    </style>\n' +
    '  </head>\n' +
    '\n' +
    '  <body>\n' +
    '    <div id="swagger-ui"></div>\n' +
    '\n' +
    '    <script src="./docs/swagger-ui-bundle.js"> </script>\n' +
    '    <script src="./docs/swagger-ui-standalone-preset.js"> </script>\n' +
    '    <script>\n' +
    '    window.onload = function() {\n' +
    '      const ui = SwaggerUIBundle({\n' +
    '        url: "./docs/swagger.json",\n' +
    '        dom_id: \'#swagger-ui\',\n' +
    '        oauth2RedirectUrl: window.location.origin + \'/docs/oauth2-redirect.html\',\n' +
    '        deepLinking: true,\n' +
    '        presets: [\n' +
    '          SwaggerUIBundle.presets.apis\n' +
    '        ],\n' +
    '        plugins: [\n' +
    '        ]\n' +
    '      })\n' +
    '      window.ui = ui\n' +
    '    }\n' +
    '  </script>\n' +
    '  </body>\n' +
    '</html>\n';
SwaggerGenerator.logger = loggerService.child({ module: 'SwaggerGenerator' });

const accepts = _accepts;
const flatstr = _flatstr;
const yaml = _yaml;
class Wireup {
    static getHandler(endpoint) {
        return (request, reply) => __awaiter(this, void 0, void 0, function* () {
            const args = endpoint.paramsOptions.map((param) => {
                switch (param.type) {
                    case 'query':
                        const value = request.query[param.name];
                        return jsonConverter.deserialize(value, param.paramType);
                    case 'path':
                        return request.params[param.name];
                    case 'body':
                        return jsonConverter.deserialize(request.body, param.paramType);
                    case 'search':
                        try {
                            return QuerySearch.fromQueryParams(request.query);
                        }
                        catch (err) {
                            throw new WebServiceError(err.message, 400);
                        }
                    case 'httpRequest':
                        return request;
                    case 'httpReply':
                        return reply;
                    case 'auth':
                        return request.user;
                    default:
                        return undefined;
                }
            });
            return endpoint.controller[endpoint.method].apply(endpoint.controller, args)
                .then((result) => {
                if (!reply.sent && result === undefined) {
                    reply.status(204);
                }
                return result;
            });
        });
    }
    static getAuthorizationHandler(container, endpoint) {
        function sendUnauthorized(reply, reason) {
            const body = { reason };
            reply.status(401).send(body);
        }
        if (!endpoint.methodOptions.auth) {
            return;
        }
        const authOptions = AuthUtil.normalizeAuthOptions(endpoint.methodOptions.auth);
        const authProviders = AuthUtil.getAuthProviders(container, authOptions);
        return (request, reply) => __awaiter(this, void 0, void 0, function* () {
            let token;
            try {
                token = AuthUtil.parseAuthorizationHeader(request);
            }
            catch (err) {
                sendUnauthorized(reply, err);
                return;
            }
            let user;
            let options;
            const errors = {};
            for (const a of authProviders) {
                try {
                    user = yield a.provider.authenticate(request, token, a.options);
                    options = a.options;
                    break;
                }
                catch (err) {
                    errors[a.options.providerName] = err.message;
                    request.log.warn('Cannot authenticate using authenticator', a.options.providerName);
                }
            }
            if (user) {
                if (options.role && !request.user.hasRole(options.role)) {
                    sendUnauthorized(reply, `User should have role <${options.role}>`);
                }
                request.user = user;
                request.log.info({ login: request.user.login }, 'authenticated successfully');
            }
            else {
                sendUnauthorized(reply, errors);
            }
            return;
        });
    }
    static getJsonSerializer() {
        return (data) => {
            const json = jsonConverter.serialize(data, undefined, { unsafe: true });
            return flatstr(JSON.stringify(json));
        };
    }
    static getYamlSerializer() {
        return (data) => {
            const json = jsonConverter.serialize(data, undefined, { unsafe: true });
            return flatstr(yaml.safeDump(json));
        };
    }
    static getSerializerHandler() {
        return (request, reply, done) => {
            const accept = accepts(request);
            switch (accept.type(['json', 'application/x-yaml'])) {
                case 'json':
                    reply.header('Content-Type', 'application/json')
                        .serializer(Wireup.getJsonSerializer());
                    break;
                case 'application/x-yaml':
                    reply.header('Content-Type', 'application/x-yaml')
                        .serializer(Wireup.getYamlSerializer());
                    break;
            }
            done();
        };
    }
    static getPlugin(instance, opts, next) {
        const logger = Wireup.logger.child({ method: 'getPlugin' });
        logger.info('initializing wireup...');
        CommonUtil.getAllEndpoints(opts.container).forEach((endpoint) => {
            instance.route({
                handler: Wireup.getHandler(endpoint),
                method: endpoint.methodOptions.method,
                onRequest: [
                    Wireup.getAuthorizationHandler(opts.container, endpoint)
                ]
                    .filter((handler) => handler !== undefined),
                preHandler: [
                    Wireup.getSerializerHandler()
                ]
                    .filter((handler) => handler !== undefined),
                url: endpoint.url,
            });
            logger.debug(`[${endpoint.methodOptions.method}] ${endpoint.url}`);
        });
        logger.info('wireup initialized');
        next();
    }
}
Wireup.logger = loggerService.child({ module: 'Wireup' });

const fastify = _fastify;
class Server {
    constructor(options) {
        this.buildInstance(options);
        this._instance.ready(() => {
            this._instance.log.info('server started');
        });
    }
    get instance() {
        return this._instance;
    }
    buildInstance(options) {
        options.logger = options.logger || loggerService;
        options.genReqId = () => generate();
        options.requestIdHeader = 'request-id';
        this._instance = fastify(options);
        this._instance.register(helmet);
        this._instance.use(loggerContextMiddleware);
        options.container.bind(types.Logger).toConstantValue(this._instance.log);
        this._instance.register(fastifyCompress);
        if (options.healthcheck !== false) {
            options.container.bind(types.Controller).to(HealthcheckController).inSingletonScope();
        }
        if (options.admin) {
            const adminController = new AdminController(typeof options.admin === 'boolean' ? undefined : options.admin);
            options.container.bind(types.Controller).toConstantValue(adminController);
        }
        this._instance.register(Wireup.getPlugin, { container: options.container });
        if (options.metrics !== false) {
            const endpoint = typeof (options.metrics) === 'string' ? options.metrics : '/metrics';
            this._instance.register(fastifyMetrics, { endpoint });
        }
        if (options.mongo) {
            options.container.bind(types.MongoService).to(MongoService).inSingletonScope();
            options.container.bind(types.Healthcheck).to(MongoHealthcheck).inSingletonScope();
            const service = options.container.get(types.MongoService);
            service.connect(typeof (options.mongo) === 'boolean' ? undefined : options.mongo);
        }
        if (options.auth) {
            if (options.auth.jwt) {
                const jwtAuthProviderOptions = typeof (options.auth.jwt) === 'boolean' ? undefined : options.auth.jwt;
                const jwtAuthProvider = new JwtAuthProvider(jwtAuthProviderOptions);
                options.container.bind(types.AuthProvider)
                    .toConstantValue(jwtAuthProvider)
                    .whenTargetNamed('jwt');
            }
            if (options.auth.basic) {
                const basicAuthProviderOptions = typeof (options.auth.basic) === 'boolean' ? undefined : options.auth.basic;
                const basicAuthProvider = new BasicAuthProvider(basicAuthProviderOptions);
                options.container.bind(types.AuthProvider)
                    .toConstantValue(basicAuthProvider)
                    .whenTargetNamed('basic');
            }
        }
        if (options.swagger !== false) {
            this._instance.register(SwaggerGenerator.getPlugin, {
                configuration: typeof (options.swagger) === 'boolean' ? undefined : options.swagger,
                container: options.container,
            });
        }
    }
    listen(port = environment.PORT) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._instance.listen(port, '0.0.0.0');
        });
    }
}

class ControllerTest {
    constructor(container) {
        this._server = new Server({
            auth: {},
            container,
            healthcheck: false,
            metrics: false,
            mongo: false,
            swagger: false,
        });
    }
    get server() {
        return this._server.instance.server;
    }
}

export { AuthProvider, AuthUtil, BasicAuthProvider, CommonUtil, ControllerTest, DEFAULT_BASIC_AUTH_PROVIDER_OPTIONS, DEFAULT_JWT_AUTH_PROVIDER_OPTIONS, DEFAULT_LOGGER_OPTIONS, DEFAULT_MONGO_OPTIONS, GenericClient, GenericClientError, HealthcheckController, JwtAuthProvider, MONGO_COLLECTION, MongoHealthcheck, MongoService, OPENAPI_DEFAULT_CONFIGURATION, Principal, ROUTE_CONTROLLER, ROUTE_METHOD, ROUTE_PARAMS, Server, SwaggerGenerator, WebServiceError, Wireup, auth, body, collection, controller, environment, genericClient, getLogger, getReqId, http, httpDelete, httpGet, httpPatch, httpPost, httpPut, httpReply, httpRequest, jsonConverter, loggerContextMiddleware, loggerService, objectIdCustomConverter, pathParam, queryParam, querySearch, types };
